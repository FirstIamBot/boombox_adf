// ...existing code...

typedef enum {
    SOURCE_BLUETOOTH,
    SOURCE_HTTP
} audio_source_t;

static audio_source_t current_source = SOURCE_HTTP;
static audio_pipeline_handle_t pipeline = NULL;
static esp_periph_set_handle_t periph_set = NULL;
static audio_event_iface_handle_t evt = NULL;
static audio_board_handle_t board_handle = NULL;
static bool pipeline_running = false;

static esp_err_t input_key_service_cb(periph_service_handle_t handle, periph_service_event_t *evt, void *ctx)
{
    if (evt->type == INPUT_KEY_SERVICE_ACTION_CLICK_RELEASE) {
        ESP_LOGI(TAG, "[ * ] input key id is %d", (int)evt->data);
        switch ((int)evt->data) {
            case INPUT_KEY_USER_ID_PLAY:
                ESP_LOGI(TAG, "[ * ] [Play] toggle source");
                // Переключение между BT и HTTP
                if (current_source == SOURCE_BLUETOOTH) {
                    current_source = SOURCE_HTTP;
                    ESP_LOGI(TAG, "Switching to HTTP player");
                } else {
                    current_source = SOURCE_BLUETOOTH;
                    ESP_LOGI(TAG, "Switching to Bluetooth player");
                }
                // Перезапуск с новым источником
                stop_current_pipeline();
                vTaskDelay(1000 / portTICK_PERIOD_MS);
                start_pipeline_for_source(current_source);
                break;
            case INPUT_KEY_USER_ID_SET:
                ESP_LOGI(TAG, "[ * ] [Set] pause/resume");
                if (current_source == SOURCE_BLUETOOTH) {
                    periph_bt_pause(bt_periph);
                } else {
                    // Для HTTP можно остановить/запустить pipeline
                    if (pipeline_running) {
                        audio_pipeline_pause(pipeline);
                        pipeline_running = false;
                    } else {
                        audio_pipeline_resume(pipeline);
                        pipeline_running = true;
                    }
                }
                break;
            case INPUT_KEY_USER_ID_VOLUP:
                ESP_LOGI(TAG, "[ * ] [Vol+] Volume up");
                if (current_source == SOURCE_BLUETOOTH) {
                    periph_bt_volume_up(bt_periph);
                }
                break;
            case INPUT_KEY_USER_ID_VOLDOWN:
                ESP_LOGI(TAG, "[ * ] [Vol-] Volume down");
                if (current_source == SOURCE_BLUETOOTH) {
                    periph_bt_volume_down(bt_periph);
                }
                break;
        }
    }
    return ESP_OK;
}

void stop_current_pipeline()
{
    if (pipeline && pipeline_running) {
        ESP_LOGI(TAG, "Stopping current pipeline");
        audio_pipeline_stop(pipeline);
        audio_pipeline_wait_for_stop(pipeline);
        audio_pipeline_terminate(pipeline);
        pipeline_running = false;
    }
}

void start_pipeline_for_source(audio_source_t source)
{
    if (source == SOURCE_BLUETOOTH) {
        start_bluetooth_pipeline();
    } else {
        start_http_pipeline();
    }
}

void start_bluetooth_pipeline()
{
    ESP_LOGI(TAG, "Starting Bluetooth pipeline");
    
    audio_element_handle_t bt_stream_reader, i2s_stream_writer;
    
    // Инициализация Bluetooth если еще не инициализирован
    static bool bt_initialized = false;
    if (!bt_initialized) {
        ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_BLE));
        esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
        ESP_ERROR_CHECK(esp_bt_controller_init(&bt_cfg));
        ESP_ERROR_CHECK(esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT));
        ESP_ERROR_CHECK(esp_bluedroid_init());
        ESP_ERROR_CHECK(esp_bluedroid_enable());
        
        esp_bt_dev_set_device_name("ESP_BT_HTTP_PLAYER");
        esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);
        bt_initialized = true;
    }

    // Создание нового pipeline
    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
    pipeline = audio_pipeline_init(&pipeline_cfg);

    // I2S writer
    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
    i2s_cfg.type = AUDIO_STREAM_WRITER;
    i2s_stream_writer = i2s_stream_init(&i2s_cfg);

    // Bluetooth stream
    a2dp_stream_config_t a2dp_config = {
        .type = AUDIO_STREAM_READER,
        .user_callback = {0},
    };
    bt_stream_reader = a2dp_stream_init(&a2dp_config);

    // Регистрация элементов
    audio_pipeline_register(pipeline, bt_stream_reader, "bt");
    audio_pipeline_register(pipeline, i2s_stream_writer, "i2s");

    // Связывание
    const char *link_tag[2] = {"bt", "i2s"};
    audio_pipeline_link(pipeline, &link_tag[0], 2);

    // Создание BT peripheral если еще не создан
    if (bt_periph == NULL) {
        bt_periph = bt_create_periph();
        esp_periph_start(periph_set, bt_periph);
    }

    audio_pipeline_set_listener(pipeline, evt);
    audio_pipeline_run(pipeline);
    pipeline_running = true;
}

void start_http_pipeline()
{
    ESP_LOGI(TAG, "Starting HTTP pipeline");
    
    audio_element_handle_t http_stream_reader, i2s_stream_writer, selected_decoder;

    // Создание нового pipeline
    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
    pipeline = audio_pipeline_init(&pipeline_cfg);

    // HTTP stream
    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
    http_cfg.out_rb_size = 1024 * 1024;
    http_stream_reader = http_stream_init(&http_cfg);

    // MP3 decoder
    mp3_decoder_cfg_t mp3_cfg = DEFAULT_MP3_DECODER_CONFIG();
    selected_decoder = mp3_decoder_init(&mp3_cfg);

    // I2S writer
    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
    i2s_cfg.type = AUDIO_STREAM_WRITER;
    i2s_stream_writer = i2s_stream_init(&i2s_cfg);

    // Регистрация элементов
    audio_pipeline_register(pipeline, http_stream_reader, "http");
    audio_pipeline_register(pipeline, selected_decoder, "mp3");
    audio_pipeline_register(pipeline, i2s_stream_writer, "i2s");

    // Связывание
    const char *link_tag[3] = {"http", "mp3", "i2s"};
    audio_pipeline_link(pipeline, &link_tag[0], 3);

    // Установка URI
    audio_element_set_uri(http_stream_reader, selected_file_to_play);

    audio_pipeline_set_listener(pipeline, evt);
    audio_pipeline_run(pipeline);
    pipeline_running = true;
}

void combined_player()
{
    ESP_LOGI(TAG, "[ * ] Combined BT/HTTP player started");
    
    // Инициализация NVS
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(esp_netif_init());

    esp_log_level_set("*", ESP_LOG_INFO);
    esp_log_level_set(TAG, ESP_LOG_DEBUG);

    // Инициализация аудио чипа
    board_handle = audio_board_init();
    audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START);

    // Инициализация периферии
    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
    periph_set = esp_periph_set_init(&periph_cfg);

    // Инициализация WiFi
    periph_wifi_cfg_t wifi_cfg = {
        .wifi_config.sta.ssid = CONFIG_WIFI_SSID,
        .wifi_config.sta.password = CONFIG_WIFI_PASSWORD,
    };
    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
    esp_periph_start(periph_set, wifi_handle);
    periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY);

    // Инициализация кнопок
    audio_board_key_init(periph_set);
    input_key_service_info_t input_key_info[] = INPUT_KEY_DEFAULT_INFO();
    input_key_service_cfg_t input_cfg = INPUT_KEY_SERVICE_DEFAULT_CONFIG();
    input_cfg.handle = periph_set;
    periph_service_handle_t input_ser = input_key_service_create(&input_cfg);
    input_key_service_add_key(input_ser, input_key_info, INPUT_KEY_NUM);
    periph_service_set_callback(input_ser, input_key_service_cb, NULL);

    // Инициализация событий
    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
    evt = audio_event_iface_init(&evt_cfg);
    audio_event_iface_set_listener(esp_periph_set_get_event_iface(periph_set), evt);

    // Запуск с HTTP по умолчанию
    start_pipeline_for_source(current_source);

    // Основной цикл событий
    while (1) {
        audio_event_iface_msg_t msg;
        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
            continue;
        }

        // Обработка событий в зависимости от текущего источника
        if (current_source == SOURCE_BLUETOOTH) {
            // Обработка событий Bluetooth
            if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT 
                && msg.cmd == AEL_MSG_CMD_REPORT_MUSIC_INFO) {
                audio_element_info_t music_info = {0};
                audio_element_getinfo((audio_element_handle_t)msg.source, &music_info);
                ESP_LOGI(TAG, "BT Music info: rate=%d, bits=%d, ch=%d",
                         music_info.sample_rates, music_info.bits, music_info.channels);
            }
        } else {
            // Обработка событий HTTP
            if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT 
                && msg.cmd == AEL_MSG_CMD_REPORT_MUSIC_INFO) {
                audio_element_info_t music_info = {0};
                audio_element_getinfo((audio_element_handle_t)msg.source, &music_info);
                ESP_LOGI(TAG, "HTTP Music info: rate=%d, bits=%d, ch=%d",
                         music_info.sample_rates, music_info.bits, music_info.channels);
            }
        }
    }
}

void app_main(void)
{
    combined_player();
}